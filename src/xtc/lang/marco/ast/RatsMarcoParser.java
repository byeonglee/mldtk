// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 2.3.1,
// (C) 2004-2012 Robert Grimm,
// on Saturday, December 4, 2021 at 6:07:32 PM.
// Edit at your own risk.
// ===========================================================================

package xtc.lang.marco.ast;

import java.io.Reader;
import java.io.IOException;

import xtc.util.Pair;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import xtc.lang.marco.type.CodeType;
import xtc.lang.marco.type.PrimitiveType;
import xtc.tree.Location;
import xtc.util.Action;

/**
 * Packrat parser for grammar <code>Marco</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 2.3.1, (C) 2004-2012 Robert Grimm.
 */
public final class RatsMarcoParser extends ParserBase {

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result ftype;
    Result fattributeDecl;
    Result ffuncFormal;
    Result fstmt;
    Result fblockStmt;
    Result fblockStmt$$Star1;
    Result fexpr;
    Result flogicalOrExpr;
    Result flogicalOrExpr$$Star1;
    Result flogicalAndExpr;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result flogicalAndExpr$$Star1;
    Result fbitwiseOrExpr;
    Result fbitwiseOrExpr$$Star1;
    Result fbitwiseXorExpr;
    Result fbitwiseXorExpr$$Star1;
    Result fbitwiseAndExpr;
    Result fbitwiseAndExpr$$Star1;
    Result fcomparisonExpr;
    Result fcomparisonExpr$$Star1;
    Result fshiftExpr;
  }

  /** Chunk 3 of memoized results. */
  static final class Chunk3 {
    Result fshiftExpr$$Star1;
    Result fadditiveExpr;
    Result fadditiveExpr$$Star1;
    Result fmultiplicativeExpr;
    Result fmultiplicativeExpr$$Star1;
    Result funaryExpr;
    Result fintLit;
    Result fid;
    Result fannotationProperty;
    Result fcaptuableName;
  }

  /** Chunk 4 of memoized results. */
  static final class Chunk4 {
    Result fphraseType;
    Result fcppFragmentBody;
    Result fcppFragmentBody$$Star1;
    Result f$$Shared1;
    Result f$$Shared2;
    Result f$$Shared3;
    Result f$$Shared3$$Star1;
    Result f$$Shared4;
    Result fCPP_WS;
    Result fsqlFragmentBody;
  }

  /** Chunk 5 of memoized results. */
  static final class Chunk5 {
    Result fsqlFragmentBody$$Star1;
    Result fSQL_WS;
    Result fFOR;
    Result fID_KEYWORD;
    Result fIF;
    Result fIN;
    Result fINT;
    Result fTYPE;
    Result fASSIGN;
    Result fBACK_TICK;
  }

  /** Chunk 6 of memoized results. */
  static final class Chunk6 {
    Result fCOMMA;
    Result fGREATER;
    Result fLBRACKET;
    Result fLESS;
    Result fLPAREN;
    Result fRBRACKET;
    Result fRPAREN;
    Result fSEMI;
    Result fID;
    Result fID_INTERNAL;
  }

  /** Chunk 7 of memoized results. */
  static final class Chunk7 {
    Result fID_INTERNAL$$Star1;
    Result fWS;
    Result fNEWLINE;
    Result fEOF;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class RatsMarcoParserColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
    Chunk3 chunk3;
    Chunk4 chunk4;
    Chunk5 chunk5;
    Chunk6 chunk6;
    Chunk7 chunk7;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public RatsMarcoParser(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public RatsMarcoParser(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new RatsMarcoParserColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.program.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pprogram(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyRepetition1;
    Pair<TopLevelAst> yyRepValue1;
    ProgramAst        yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWS(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = ptopLevelDeclOrDef(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          TopLevelAst v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<TopLevelAst>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for t.
        Pair<TopLevelAst> t = yyRepValue1.reverse();

        yyResult = pEOF(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue=new ProgramAst(l(yyStart), t.list().toArray(new TopLevelAst[0]));

          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for t.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.topLevelDeclOrDef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptopLevelDeclOrDef(final int yyStart) throws IOException {
    Result      yyResult;
    TopLevelAst yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pimportDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = ptypeDef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pfunctionDef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pexternFuncDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pconstDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.importDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pimportDecl(final int yyStart) throws IOException {
    Result     yyResult;
    ImportDecl yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIMPORT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pid(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        NameAst i = yyResult.semanticValue();

        yyResult = pSEMI(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue=new ImportDecl(l(yyStart), i);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.typeDef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptypeDef(final int yyStart) throws IOException {
    Result     yyResult;
    TypeDef    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTYPE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pid(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        NameAst i = yyResult.semanticValue();

        yyResult = pASSIGN(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = ptype(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            TypeAst t = yyResult.semanticValue();

            yyResult = pSEMI(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue=new TypeDef(l(yyStart), i, t);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.type.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptype(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.ftype) 
      yyColumn.chunk1.ftype = ptype$1(yyStart);
    return yyColumn.chunk1.ftype;
  }

  /** Actually parse Marco.type. */
  private Result ptype$1(final int yyStart) throws IOException {
    Result     yyResult;
    TypeAst    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pid(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NameAst i = yyResult.semanticValue();

      yyValue=new UserTypeAst(l(yyStart), i);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pVOID(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=new VoidTypeAst(l(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pprimitiveType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pcodeType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pcompositeType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.codeType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcodeType(final int yyStart) throws IOException {
    Result      yyResult;
    CodeTypeAst yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCODE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pLESS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pfragmentLanguage(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String f = yyResult.semanticValue();

          yyResult = pCOMMA(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pphraseType(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              String p = yyResult.semanticValue();

              yyResult = pGREATER(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue=new CodeTypeAst(l(yyStart), new CodeType(f, p));

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.primitiveType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pprimitiveType(final int yyStart) throws IOException {
    Result           yyResult;
    PrimitiveTypeAst yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBOOLEAN(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=new PrimitiveTypeAst(l(yyStart), PrimitiveType.BOOLEAN,"boolean");

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pINT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=new PrimitiveTypeAst(l(yyStart), PrimitiveType.INT,    "int");

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pDOUBLE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=new PrimitiveTypeAst(l(yyStart), PrimitiveType.DOUBLE, "double");

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pSTRING(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=new PrimitiveTypeAst(l(yyStart), PrimitiveType.STRING, "string");

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.compositeType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcompositeType(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<AttributeAst> yyRepValue1;
    CompositeTypeAst   yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTUPLE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pLESS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pattributeDecl(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          AttributeAst h = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pCOMMA(yyRepetition1);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {

              yyResult = pattributeDecl(yyResult.index);
              yyError  = yyResult.select(yyError, yyRepetition1);
              if (yyResult.hasValue()) {
                AttributeAst v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<AttributeAst>(v$el$1, yyRepValue1);
                continue;
              }
            }
            break;
          }
          { // Start scope for t.
            Pair<AttributeAst> t = yyRepValue1.reverse();

            yyResult = pGREATER(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue=new TupleTypeAst(l(yyStart),
              new Pair<AttributeAst>(h, t).list().toArray(new AttributeAst[0]));

              return yyResult.createValue(yyValue, yyError);
            }
          } // End scope for t.
        }
      }
    }

    // Alternative 2.

    yyResult = pLIST(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pLESS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = ptype(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          TypeAst t = yyResult.semanticValue();

          yyResult = pGREATER(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue=new ListTypeAst(l(yyStart), t);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.attributeDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pattributeDecl(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fattributeDecl) 
      yyColumn.chunk1.fattributeDecl = pattributeDecl$1(yyStart);
    return yyColumn.chunk1.fattributeDecl;
  }

  /** Actually parse Marco.attributeDecl. */
  private Result pattributeDecl$1(final int yyStart) throws IOException {
    Result       yyResult;
    AttributeAst yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ptype(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TypeAst t = yyResult.semanticValue();

      yyResult = pid(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        NameAst i = yyResult.semanticValue();

        yyValue=new AttributeAst(l(yyStart), i, t);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.externFuncDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pexternFuncDecl(final int yyStart) throws IOException {
    Result        yyResult;
    int           yyRepetition1;
    Pair<TypeAst> yyRepValue1;
    ExterFuncDecl yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEXTERN(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = ptype(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        TypeAst r = yyResult.semanticValue();

        yyResult = pid(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          NameAst i = yyResult.semanticValue();

          yyResult = pLPAREN(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = ptype(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              TypeAst h = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = Pair.empty();
              while (true) {

                yyResult = pCOMMA(yyRepetition1);
                yyError  = yyResult.select(yyError, yyRepetition1);
                if (yyResult.hasValue()) {

                  yyResult = ptype(yyResult.index);
                  yyError  = yyResult.select(yyError, yyRepetition1);
                  if (yyResult.hasValue()) {
                    TypeAst v$el$1 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepValue1   = new Pair<TypeAst>(v$el$1, yyRepValue1);
                    continue;
                  }
                }
                break;
              }
              { // Start scope for t.
                Pair<TypeAst> t = yyRepValue1.reverse();

                yyResult = pRPAREN(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pSEMI(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyValue=new ExterFuncDecl(l(yyStart), i, r,
                    new Pair<TypeAst>(h, t).list().toArray(new TypeAst[0]));

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              } // End scope for t.
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.functionDef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfunctionDef(final int yyStart) throws IOException {
    Result               yyResult;
    int                  yyRepetition1;
    Pair<FormalParamAst> yyRepValue1;
    FuncDefinition       yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ptype(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TypeAst r = yyResult.semanticValue();

      yyResult = pid(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        NameAst i = yyResult.semanticValue();

        yyResult = pLPAREN(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyResult = pfuncFormal(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            FormalParamAst h = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = Pair.empty();
            while (true) {

              yyResult = pCOMMA(yyRepetition1);
              yyError  = yyResult.select(yyError, yyRepetition1);
              if (yyResult.hasValue()) {

                yyResult = pfuncFormal(yyResult.index);
                yyError  = yyResult.select(yyError, yyRepetition1);
                if (yyResult.hasValue()) {
                  FormalParamAst v$el$1 = yyResult.semanticValue();

                  yyRepetition1 = yyResult.index;
                  yyRepValue1   = 
                    new Pair<FormalParamAst>(v$el$1, yyRepValue1);
                  continue;
                }
              }
              break;
            }
            { // Start scope for t.
              Pair<FormalParamAst> t = yyRepValue1.reverse();

              yyResult = pRPAREN(yyRepetition1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pblockStmt(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  BlockStmtAst b = yyResult.semanticValue();

                  yyValue=new FuncDefinition(l(yyStart), r, i,
                  new Pair<FormalParamAst>(h, t).list().toArray(new FormalParamAst[0]),
                  b);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            } // End scope for t.
          }

          // Nested alternative 2.

          yyResult = pRPAREN(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pblockStmt(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              BlockStmtAst b = yyResult.semanticValue();

              yyValue=new FuncDefinition(l(yyStart), r, i, new FormalParamAst[0], b);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.funcFormal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfuncFormal(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.ffuncFormal) 
      yyColumn.chunk1.ffuncFormal = pfuncFormal$1(yyStart);
    return yyColumn.chunk1.ffuncFormal;
  }

  /** Actually parse Marco.funcFormal. */
  private Result pfuncFormal$1(final int yyStart) throws IOException {
    Result         yyResult;
    FormalParamAst yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ptype(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TypeAst t = yyResult.semanticValue();

      yyResult = pid(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        NameAst i = yyResult.semanticValue();

        yyValue=new FormalParamAst(l(yyStart), i, t);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.constDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pconstDecl(final int yyStart) throws IOException {
    Result       yyResult;
    ConstDeclAst yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCONST(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pINT(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pid(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          NameAst l = yyResult.semanticValue();

          yyResult = pASSIGN(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pintLit(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              NumAst r = yyResult.semanticValue();

              yyResult = pSEMI(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue=new ConstDeclAst(l(yyStart), l, r);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.stmt.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pstmt(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fstmt) 
      yyColumn.chunk1.fstmt = pstmt$1(yyStart);
    return yyColumn.chunk1.fstmt;
  }

  /** Actually parse Marco.stmt. */
  private Result pstmt$1(final int yyStart) throws IOException {
    Result     yyResult;
    StmtAst    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pblockStmt(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pdeclStmt(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = passignStmt(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pexprStmt(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pifStmt(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pforStmt(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = preturnStmt(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = passertStmt(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.blockStmt.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pblockStmt(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fblockStmt) 
      yyColumn.chunk1.fblockStmt = pblockStmt$1(yyStart);
    return yyColumn.chunk1.fblockStmt;
  }

  /** Actually parse Marco.blockStmt. */
  private Result pblockStmt$1(final int yyStart) throws IOException {
    Result       yyResult;
    BlockStmtAst yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLBRACE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pblockStmt$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<StmtAst> s = yyResult.semanticValue();

        yyResult = prbrace(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Location r = yyResult.semanticValue();

          yyValue=new BlockStmtAst(l(yyStart), s.list().toArray(new StmtAst[0]),
          r.line, r.column);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Marco.blockStmt$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pblockStmt$$Star1(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fblockStmt$$Star1) 
      yyColumn.chunk1.fblockStmt$$Star1 = pblockStmt$$Star1$1(yyStart);
    return yyColumn.chunk1.fblockStmt$$Star1;
  }

  /** Actually parse Marco.blockStmt$$Star1. */
  private Result pblockStmt$$Star1$1(final int yyStart) throws IOException {
    Result        yyResult;
    Pair<StmtAst> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pstmt(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      StmtAst v$el$1 = yyResult.semanticValue();

      yyResult = pblockStmt$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<StmtAst> v$2 = yyResult.semanticValue();

        yyValue = new Pair<StmtAst>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.rbrace.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result prbrace(final int yyStart) throws IOException {
    Result     yyResult;
    Location   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRBRACE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=l(yyStart);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.declStmt.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdeclStmt(final int yyStart) throws IOException {
    Result      yyResult;
    DeclStmtAst yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ptype(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TypeAst t = yyResult.semanticValue();

      yyResult = pid(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        NameAst i = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pASSIGN(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pexpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            ExprAst e = yyResult.semanticValue();

            yyResult = pSEMI(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue=new DeclStmtAst(l(yyStart), t, i, e);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }

        // Nested alternative 2.

        yyResult = pSEMI(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue=new DeclStmtAst(l(yyStart), t, i, null);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.assignStmt.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result passignStmt(final int yyStart) throws IOException {
    Result        yyResult;
    AssignStmtAst yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pid(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NameAst i = yyResult.semanticValue();

      yyResult = passignOp(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        InfixOp a = yyResult.semanticValue();

        yyResult = pexpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          ExprAst e = yyResult.semanticValue();

          yyResult = pSEMI(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue=new AssignStmtAst(l(yyStart), i, a, e);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.exprStmt.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pexprStmt(final int yyStart) throws IOException {
    Result      yyResult;
    ExprStmtAst yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pexpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ExprAst e = yyResult.semanticValue();

      yyResult = pSEMI(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue=new ExprStmtAst(l(yyStart), e);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.assignOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result passignOp(final int yyStart) throws IOException {
    Result     yyResult;
    InfixOp    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pASSIGN(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=InfixOp.ASSIGN;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pASSIGN_PLUS(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=InfixOp.ASSIGN_PLUS;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.ifStmt.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pifStmt(final int yyStart) throws IOException {
    Result     yyResult;
    IfStmtAst  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIF(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pLPAREN(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pexpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          ExprAst e = yyResult.semanticValue();

          yyResult = pRPAREN(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pstmt(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              StmtAst t = yyResult.semanticValue();

              final int yyChoice1 = yyResult.index;

              // Nested alternative 1.

              yyResult = pELSE(yyChoice1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pstmt(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  StmtAst f = yyResult.semanticValue();

                  yyValue=new IfStmtAst(l(yyStart), e, t, f);

                  return yyResult.createValue(yyValue, yyError);
                }
              }

              // Nested alternative 2.

              yyValue=new IfStmtAst(l(yyStart), e, t, null);

              return new SemanticValue(yyValue, yyChoice1, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.forStmt.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pforStmt(final int yyStart) throws IOException {
    Result     yyResult;
    ForStmtAst yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFOR(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pLPAREN(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = ptype(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          TypeAst t = yyResult.semanticValue();

          yyResult = pid(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            NameAst i = yyResult.semanticValue();

            yyResult = pIN(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pexpr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                ExprAst e = yyResult.semanticValue();

                yyResult = pRPAREN(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  final int yyChoice1 = yyResult.index;

                  // Nested alternative 1.

                  yyResult = pWITH(yyChoice1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pid(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      NameAst v = yyResult.semanticValue();

                      yyResult = pstmt(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        StmtAst s = yyResult.semanticValue();

                        yyValue=new ForStmtAst(l(yyStart), t, i, e, s, v);

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  }

                  // Nested alternative 2.

                  yyResult = pstmt(yyChoice1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    StmtAst s = yyResult.semanticValue();

                    yyValue=new ForStmtAst(l(yyStart), t, i, e, s, null);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.returnStmt.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result preturnStmt(final int yyStart) throws IOException {
    Result     yyResult;
    ReturnStmt yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRETURN(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pexpr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        ExprAst e = yyResult.semanticValue();

        yyResult = pSEMI(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue=new ReturnStmt(l(yyStart), e);

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      yyResult = pSEMI(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue=new ReturnStmt(l(yyStart), null);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.assertStmt.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result passertStmt(final int yyStart) throws IOException {
    Result     yyResult;
    AssertStmt yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pASSERT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pexpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        ExprAst c = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pCOLON(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pexpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            ExprAst m = yyResult.semanticValue();

            final int yyChoice2 = yyResult.index;

            // Nested alternative 1.

            yyResult = pCOMMA(yyChoice2);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pexpr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                ExprAst l = yyResult.semanticValue();

                yyResult = pSEMI(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue=new AssertStmt(l(yyStart), c, m, l);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }

            // Nested alternative 2.

            yyResult = pSEMI(yyChoice2);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue=new AssertStmt(l(yyStart), c, m, null);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }

        // Nested alternative 2.

        yyResult = pSEMI(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue=new AssertStmt(l(yyStart), c, null, null);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.expr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pexpr(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fexpr) 
      yyColumn.chunk1.fexpr = pexpr$1(yyStart);
    return yyColumn.chunk1.fexpr;
  }

  /** Actually parse Marco.expr. */
  private Result pexpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    ExprAst    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pmembershipExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.membershipExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmembershipExpr(final int yyStart) throws IOException {
    Result                yyResult;
    int                   yyRepetition1;
    Pair<Action<ExprAst>> yyRepValue1;
    ExprAst               yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = plogicalOrExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ExprAst h = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pmembershipExprTrail(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          Action<ExprAst> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<ExprAst>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for t.
        Pair<Action<ExprAst>> t = yyRepValue1.reverse();

        yyValue=apply(t, h);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for t.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.membershipExprTrail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmembershipExprTrail(final int yyStart) throws IOException {
    Result          yyResult;
    Action<ExprAst> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pmembershipOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final InfixOp o = yyResult.semanticValue();

      yyResult = plogicalOrExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final ExprAst t = yyResult.semanticValue();

        yyValue=new Action<ExprAst>() { public ExprAst run(ExprAst h) {
            return new InfixExprAst(o, h, t);}};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.membershipOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmembershipOp(final int yyStart) throws IOException {
    Result     yyResult;
    InfixOp    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIN(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=InfixOp.MEMBERSHIP;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.logicalOrExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result plogicalOrExpr(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.flogicalOrExpr) 
      yyColumn.chunk1.flogicalOrExpr = plogicalOrExpr$1(yyStart);
    return yyColumn.chunk1.flogicalOrExpr;
  }

  /** Actually parse Marco.logicalOrExpr. */
  private Result plogicalOrExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    ExprAst    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = plogicalAndExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ExprAst h = yyResult.semanticValue();

      yyResult = plogicalOrExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<ExprAst>> t = yyResult.semanticValue();

        yyValue=apply(t, h);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Marco.logicalOrExpr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result plogicalOrExpr$$Star1(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.flogicalOrExpr$$Star1) 
      yyColumn.chunk1.flogicalOrExpr$$Star1 = plogicalOrExpr$$Star1$1(yyStart);
    return yyColumn.chunk1.flogicalOrExpr$$Star1;
  }

  /** Actually parse Marco.logicalOrExpr$$Star1. */
  private Result plogicalOrExpr$$Star1$1(final int yyStart) 
    throws IOException {

    Result                yyResult;
    Pair<Action<ExprAst>> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = plogicalOrExprTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<ExprAst> v$el$1 = yyResult.semanticValue();

      yyResult = plogicalOrExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<ExprAst>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<ExprAst>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.logicalOrExprTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result plogicalOrExprTail(final int yyStart) throws IOException {
    Result          yyResult;
    Action<ExprAst> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = plogicalOrOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final InfixOp o = yyResult.semanticValue();

      yyResult = plogicalAndExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final ExprAst t = yyResult.semanticValue();

        yyValue=new Action<ExprAst>() { public ExprAst run(ExprAst h) {
            return new InfixExprAst(o, h, t);}};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.logicalOrOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result plogicalOrOp(final int yyStart) throws IOException {
    Result     yyResult;
    InfixOp    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLOGICAL_OR(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=InfixOp.LOGICAL_OR;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.logicalAndExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result plogicalAndExpr(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.flogicalAndExpr) 
      yyColumn.chunk1.flogicalAndExpr = plogicalAndExpr$1(yyStart);
    return yyColumn.chunk1.flogicalAndExpr;
  }

  /** Actually parse Marco.logicalAndExpr. */
  private Result plogicalAndExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    ExprAst    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbitwiseOrExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ExprAst h = yyResult.semanticValue();

      yyResult = plogicalAndExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<ExprAst>> t = yyResult.semanticValue();

        yyValue=apply(t, h);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Marco.logicalAndExpr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result plogicalAndExpr$$Star1(final int yyStart) 
    throws IOException {

    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.flogicalAndExpr$$Star1) 
      yyColumn.chunk2.flogicalAndExpr$$Star1 = plogicalAndExpr$$Star1$1(yyStart);
    return yyColumn.chunk2.flogicalAndExpr$$Star1;
  }

  /** Actually parse Marco.logicalAndExpr$$Star1. */
  private Result plogicalAndExpr$$Star1$1(final int yyStart) 
    throws IOException {

    Result                yyResult;
    Pair<Action<ExprAst>> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = plogicalAndExprTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<ExprAst> v$el$1 = yyResult.semanticValue();

      yyResult = plogicalAndExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<ExprAst>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<ExprAst>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.logicalAndExprTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result plogicalAndExprTail(final int yyStart) throws IOException {
    Result          yyResult;
    Action<ExprAst> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = plogicalAndOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final InfixOp o = yyResult.semanticValue();

      yyResult = pbitwiseOrExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final ExprAst t = yyResult.semanticValue();

        yyValue=new Action<ExprAst>() { public ExprAst run(ExprAst h) {
            return new InfixExprAst(o, h, t);}};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.logicalAndOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result plogicalAndOp(final int yyStart) throws IOException {
    Result     yyResult;
    InfixOp    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLOGICAL_AND(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=InfixOp.LOGICAL_AND;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.bitwiseOrExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbitwiseOrExpr(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fbitwiseOrExpr) 
      yyColumn.chunk2.fbitwiseOrExpr = pbitwiseOrExpr$1(yyStart);
    return yyColumn.chunk2.fbitwiseOrExpr;
  }

  /** Actually parse Marco.bitwiseOrExpr. */
  private Result pbitwiseOrExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    ExprAst    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbitwiseXorExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ExprAst h = yyResult.semanticValue();

      yyResult = pbitwiseOrExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<ExprAst>> t = yyResult.semanticValue();

        yyValue=apply(t, h);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Marco.bitwiseOrExpr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbitwiseOrExpr$$Star1(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fbitwiseOrExpr$$Star1) 
      yyColumn.chunk2.fbitwiseOrExpr$$Star1 = pbitwiseOrExpr$$Star1$1(yyStart);
    return yyColumn.chunk2.fbitwiseOrExpr$$Star1;
  }

  /** Actually parse Marco.bitwiseOrExpr$$Star1. */
  private Result pbitwiseOrExpr$$Star1$1(final int yyStart) 
    throws IOException {

    Result                yyResult;
    Pair<Action<ExprAst>> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbitwiseOrExprTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<ExprAst> v$el$1 = yyResult.semanticValue();

      yyResult = pbitwiseOrExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<ExprAst>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<ExprAst>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.bitwiseOrExprTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbitwiseOrExprTail(final int yyStart) throws IOException {
    Result          yyResult;
    Action<ExprAst> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbitwiseOrOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final InfixOp o = yyResult.semanticValue();

      yyResult = pbitwiseXorExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final ExprAst t = yyResult.semanticValue();

        yyValue=new Action<ExprAst>() { public ExprAst run(ExprAst h) {
            return new InfixExprAst(o, h, t);}};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.bitwiseOrOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbitwiseOrOp(final int yyStart) throws IOException {
    Result     yyResult;
    InfixOp    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBIT_OR(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=InfixOp.BIT_OR;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.bitwiseXorExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbitwiseXorExpr(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fbitwiseXorExpr) 
      yyColumn.chunk2.fbitwiseXorExpr = pbitwiseXorExpr$1(yyStart);
    return yyColumn.chunk2.fbitwiseXorExpr;
  }

  /** Actually parse Marco.bitwiseXorExpr. */
  private Result pbitwiseXorExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    ExprAst    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbitwiseAndExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ExprAst h = yyResult.semanticValue();

      yyResult = pbitwiseXorExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<ExprAst>> t = yyResult.semanticValue();

        yyValue=apply(t, h);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Marco.bitwiseXorExpr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbitwiseXorExpr$$Star1(final int yyStart) 
    throws IOException {

    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fbitwiseXorExpr$$Star1) 
      yyColumn.chunk2.fbitwiseXorExpr$$Star1 = pbitwiseXorExpr$$Star1$1(yyStart);
    return yyColumn.chunk2.fbitwiseXorExpr$$Star1;
  }

  /** Actually parse Marco.bitwiseXorExpr$$Star1. */
  private Result pbitwiseXorExpr$$Star1$1(final int yyStart) 
    throws IOException {

    Result                yyResult;
    Pair<Action<ExprAst>> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbitwiseXorExprTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<ExprAst> v$el$1 = yyResult.semanticValue();

      yyResult = pbitwiseXorExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<ExprAst>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<ExprAst>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.bitwiseXorExprTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbitwiseXorExprTail(final int yyStart) throws IOException {
    Result          yyResult;
    Action<ExprAst> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbitwiseXorOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final InfixOp o = yyResult.semanticValue();

      yyResult = pbitwiseAndExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final ExprAst t = yyResult.semanticValue();

        yyValue=new Action<ExprAst>() { public ExprAst run(ExprAst h) {
            return new InfixExprAst(o, h, t);}};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.bitwiseXorOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbitwiseXorOp(final int yyStart) throws IOException {
    Result     yyResult;
    InfixOp    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBIT_XOR(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=InfixOp.BIT_XOR;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.bitwiseAndExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbitwiseAndExpr(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fbitwiseAndExpr) 
      yyColumn.chunk2.fbitwiseAndExpr = pbitwiseAndExpr$1(yyStart);
    return yyColumn.chunk2.fbitwiseAndExpr;
  }

  /** Actually parse Marco.bitwiseAndExpr. */
  private Result pbitwiseAndExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    ExprAst    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcomparisonExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ExprAst h = yyResult.semanticValue();

      yyResult = pbitwiseAndExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<ExprAst>> t = yyResult.semanticValue();

        yyValue=apply(t, h);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Marco.bitwiseAndExpr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbitwiseAndExpr$$Star1(final int yyStart) 
    throws IOException {

    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fbitwiseAndExpr$$Star1) 
      yyColumn.chunk2.fbitwiseAndExpr$$Star1 = pbitwiseAndExpr$$Star1$1(yyStart);
    return yyColumn.chunk2.fbitwiseAndExpr$$Star1;
  }

  /** Actually parse Marco.bitwiseAndExpr$$Star1. */
  private Result pbitwiseAndExpr$$Star1$1(final int yyStart) 
    throws IOException {

    Result                yyResult;
    Pair<Action<ExprAst>> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbitwiseAndExprTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<ExprAst> v$el$1 = yyResult.semanticValue();

      yyResult = pbitwiseAndExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<ExprAst>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<ExprAst>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.bitwiseAndExprTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbitwiseAndExprTail(final int yyStart) throws IOException {
    Result          yyResult;
    Action<ExprAst> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbitwiseAndOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final InfixOp o = yyResult.semanticValue();

      yyResult = pcomparisonExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final ExprAst t = yyResult.semanticValue();

        yyValue=new Action<ExprAst>() { public ExprAst run(ExprAst h) {
            return new InfixExprAst(o, h, t);}};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.bitwiseAndOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbitwiseAndOp(final int yyStart) throws IOException {
    Result     yyResult;
    InfixOp    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBIT_AND(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=InfixOp.BIT_AND;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.comparisonExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcomparisonExpr(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fcomparisonExpr) 
      yyColumn.chunk2.fcomparisonExpr = pcomparisonExpr$1(yyStart);
    return yyColumn.chunk2.fcomparisonExpr;
  }

  /** Actually parse Marco.comparisonExpr. */
  private Result pcomparisonExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    ExprAst    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pshiftExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ExprAst h = yyResult.semanticValue();

      yyResult = pcomparisonExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<ExprAst>> t = yyResult.semanticValue();

        yyValue=apply(t, h);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Marco.comparisonExpr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcomparisonExpr$$Star1(final int yyStart) 
    throws IOException {

    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fcomparisonExpr$$Star1) 
      yyColumn.chunk2.fcomparisonExpr$$Star1 = pcomparisonExpr$$Star1$1(yyStart);
    return yyColumn.chunk2.fcomparisonExpr$$Star1;
  }

  /** Actually parse Marco.comparisonExpr$$Star1. */
  private Result pcomparisonExpr$$Star1$1(final int yyStart) 
    throws IOException {

    Result                yyResult;
    Pair<Action<ExprAst>> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcomparisonExprTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<ExprAst> v$el$1 = yyResult.semanticValue();

      yyResult = pcomparisonExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<ExprAst>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<ExprAst>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.comparisonExprTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcomparisonExprTail(final int yyStart) throws IOException {
    Result          yyResult;
    Action<ExprAst> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcomparisonOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final InfixOp o = yyResult.semanticValue();

      yyResult = pshiftExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final ExprAst t = yyResult.semanticValue();

        yyValue=new Action<ExprAst>() { public ExprAst run(ExprAst h) {
            return new InfixExprAst(o, h, t);}};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.comparisonOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcomparisonOp(final int yyStart) throws IOException {
    Result     yyResult;
    InfixOp    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEQUAL(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=InfixOp.EQUAL;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pGREATER_EQUAL(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=InfixOp.GREATER_EQUAL;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pGREATER(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=InfixOp.GREATER;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pLESS_EQUAL(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=InfixOp.LESS_EQUAL;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pLESS(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=InfixOp.LESS;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pNOT_EQUAL(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=InfixOp.NOT_EQUAL;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.shiftExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pshiftExpr(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fshiftExpr) 
      yyColumn.chunk2.fshiftExpr = pshiftExpr$1(yyStart);
    return yyColumn.chunk2.fshiftExpr;
  }

  /** Actually parse Marco.shiftExpr. */
  private Result pshiftExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    ExprAst    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = padditiveExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ExprAst h = yyResult.semanticValue();

      yyResult = pshiftExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<ExprAst>> t = yyResult.semanticValue();

        yyValue=apply(t, h);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Marco.shiftExpr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pshiftExpr$$Star1(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fshiftExpr$$Star1) 
      yyColumn.chunk3.fshiftExpr$$Star1 = pshiftExpr$$Star1$1(yyStart);
    return yyColumn.chunk3.fshiftExpr$$Star1;
  }

  /** Actually parse Marco.shiftExpr$$Star1. */
  private Result pshiftExpr$$Star1$1(final int yyStart) throws IOException {
    Result                yyResult;
    Pair<Action<ExprAst>> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pshiftExprTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<ExprAst> v$el$1 = yyResult.semanticValue();

      yyResult = pshiftExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<ExprAst>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<ExprAst>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.shiftExprTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pshiftExprTail(final int yyStart) throws IOException {
    Result          yyResult;
    Action<ExprAst> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pshiftOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final InfixOp o = yyResult.semanticValue();

      yyResult = padditiveExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final ExprAst t = yyResult.semanticValue();

        yyValue=new Action<ExprAst>() { public ExprAst run(ExprAst h) {
            return new InfixExprAst(o, h, t);}};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.shiftOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pshiftOp(final int yyStart) throws IOException {
    Result     yyResult;
    InfixOp    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLSHIFT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=InfixOp.LSHIFT;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pRSHIFT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=InfixOp.RSHIFT;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.additiveExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result padditiveExpr(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fadditiveExpr) 
      yyColumn.chunk3.fadditiveExpr = padditiveExpr$1(yyStart);
    return yyColumn.chunk3.fadditiveExpr;
  }

  /** Actually parse Marco.additiveExpr. */
  private Result padditiveExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    ExprAst    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pmultiplicativeExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ExprAst h = yyResult.semanticValue();

      yyResult = padditiveExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<ExprAst>> t = yyResult.semanticValue();

        yyValue=apply(t, h);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Marco.additiveExpr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result padditiveExpr$$Star1(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fadditiveExpr$$Star1) 
      yyColumn.chunk3.fadditiveExpr$$Star1 = padditiveExpr$$Star1$1(yyStart);
    return yyColumn.chunk3.fadditiveExpr$$Star1;
  }

  /** Actually parse Marco.additiveExpr$$Star1. */
  private Result padditiveExpr$$Star1$1(final int yyStart) 
    throws IOException {

    Result                yyResult;
    Pair<Action<ExprAst>> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = padditiveExprTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<ExprAst> v$el$1 = yyResult.semanticValue();

      yyResult = padditiveExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<ExprAst>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<ExprAst>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.additiveExprTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result padditiveExprTail(final int yyStart) throws IOException {
    Result          yyResult;
    Action<ExprAst> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = padditiveOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final InfixOp o = yyResult.semanticValue();

      yyResult = pmultiplicativeExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final ExprAst t = yyResult.semanticValue();

        yyValue=new Action<ExprAst>() { public ExprAst run(ExprAst h) {
            return new InfixExprAst(o, h, t);}};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.additiveOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result padditiveOp(final int yyStart) throws IOException {
    Result     yyResult;
    InfixOp    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPLUS(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=InfixOp.PLUS;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pMINUS(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=InfixOp.MINUS;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.multiplicativeExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmultiplicativeExpr(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fmultiplicativeExpr) 
      yyColumn.chunk3.fmultiplicativeExpr = pmultiplicativeExpr$1(yyStart);
    return yyColumn.chunk3.fmultiplicativeExpr;
  }

  /** Actually parse Marco.multiplicativeExpr. */
  private Result pmultiplicativeExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    ExprAst    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = punaryExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ExprAst h = yyResult.semanticValue();

      yyResult = pmultiplicativeExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<ExprAst>> t = yyResult.semanticValue();

        yyValue=apply(t, h);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Marco.multiplicativeExpr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmultiplicativeExpr$$Star1(final int yyStart) 
    throws IOException {

    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fmultiplicativeExpr$$Star1) 
      yyColumn.chunk3.fmultiplicativeExpr$$Star1 = pmultiplicativeExpr$$Star1$1(yyStart);
    return yyColumn.chunk3.fmultiplicativeExpr$$Star1;
  }

  /** Actually parse Marco.multiplicativeExpr$$Star1. */
  private Result pmultiplicativeExpr$$Star1$1(final int yyStart) 
    throws IOException {

    Result                yyResult;
    Pair<Action<ExprAst>> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pmultiplicativeExprTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<ExprAst> v$el$1 = yyResult.semanticValue();

      yyResult = pmultiplicativeExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<ExprAst>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<ExprAst>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.multiplicativeExprTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmultiplicativeExprTail(final int yyStart) 
    throws IOException {

    Result          yyResult;
    Action<ExprAst> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pmultiplicativeOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final InfixOp o = yyResult.semanticValue();

      yyResult = punaryExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final ExprAst t = yyResult.semanticValue();

        yyValue=new Action<ExprAst>() { public ExprAst run(ExprAst h) {
            return new InfixExprAst(o, h, t);}};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.multiplicativeOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmultiplicativeOp(final int yyStart) throws IOException {
    Result     yyResult;
    InfixOp    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMULT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=InfixOp.MULT;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pDIVIDE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=InfixOp.DIVIDE;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pPERCENT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=InfixOp.PERCENT;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.unaryExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result punaryExpr(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.funaryExpr) 
      yyColumn.chunk3.funaryExpr = punaryExpr$1(yyStart);
    return yyColumn.chunk3.funaryExpr;
  }

  /** Actually parse Marco.unaryExpr. */
  private Result punaryExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    ExprAst    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLOGICAL_NOT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = punaryExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        ExprAst u = yyResult.semanticValue();

        yyValue=new UnaryExprAst(l(yyStart), UnaryExprAst.UnaryOperator.NOT, u);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = ppostfixExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.postfixExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ppostfixExpr(final int yyStart) throws IOException {
    Result                yyResult;
    int                   yyRepetition1;
    Pair<Action<ExprAst>> yyRepValue1;
    ExprAst               yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pprimaryExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ExprAst h = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = ppostfixExprTail(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          Action<ExprAst> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<ExprAst>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for t.
        Pair<Action<ExprAst>> t = yyRepValue1.reverse();

        yyValue=apply(t, h);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for t.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.postfixExprTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ppostfixExprTail(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyRepetition1;
    Pair<ExprAst>   yyRepValue1;
    Action<ExprAst> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLBRACKET(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pexpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final ExprAst e = yyResult.semanticValue();

        yyResult = pRBRACKET(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue=new Action<ExprAst>() { public ExprAst run(ExprAst base) {
              return new ArrayRefAst(l(yyStart), base, e);}};

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pDOT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pid(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final NameAst i = yyResult.semanticValue();

        yyValue=new Action<ExprAst>() { public ExprAst run(ExprAst base) {
            return new FieldRefAst(l(yyStart), i, base);}};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pLPAREN(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pexpr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final ExprAst h = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pCOMMA(yyRepetition1);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {

            yyResult = pexpr(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final ExprAst v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<ExprAst>(v$el$1, yyRepValue1);
              continue;
            }
          }
          break;
        }
        { // Start scope for t.
          final Pair<ExprAst> t = yyRepValue1.reverse();

          yyResult = pRPAREN(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue=new Action<ExprAst>() { public ExprAst run(ExprAst base) {
                return new CallExprAst(l(yyStart), (NameAst)base,
                new Pair<ExprAst>(h, t).list().toArray(new ExprAst[0]));}};

            return yyResult.createValue(yyValue, yyError);
          }
        } // End scope for t.
      }

      // Nested alternative 2.

      yyResult = pRPAREN(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue=new Action<ExprAst>() { public ExprAst run(ExprAst base) {
            return new CallExprAst(l(yyStart), (NameAst)base, new ExprAst[0]);}};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.primaryExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pprimaryExpr(final int yyStart) throws IOException {
    Result     yyResult;
    ExprAst    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pboolLit(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pintLit(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pstringLit(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pid(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = plistDisplay(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pfragment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pparenExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.boolLit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pboolLit(final int yyStart) throws IOException {
    Result     yyResult;
    BoolLitAst yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTRUE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=new BoolLitAst(l(yyStart), true);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pFALSE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=new BoolLitAst(l(yyStart), false);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.intLit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pintLit(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fintLit) 
      yyColumn.chunk3.fintLit = pintLit$1(yyStart);
    return yyColumn.chunk3.fintLit;
  }

  /** Actually parse Marco.intLit. */
  private Result pintLit$1(final int yyStart) throws IOException {
    Result     yyResult;
    NumAst     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String i = yyResult.semanticValue();

      yyResult = pWS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue=new NumAst(l(yyStart), Integer.valueOf(i));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.stringLit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pstringLit(final int yyStart) throws IOException {
    Result       yyResult;
    StringLitAst yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared3(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String s = yyResult.semanticValue();

      yyResult = pWS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue=new StringLitAst(l(yyStart), s.substring(1, s.length()-1));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.id.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pid(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fid) yyColumn.chunk3.fid = pid$1(yyStart);
    return yyColumn.chunk3.fid;
  }

  /** Actually parse Marco.id. */
  private Result pid$1(final int yyStart) throws IOException {
    Result     yyResult;
    NameAst    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pID(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String i = yyResult.semanticValue();

      yyValue=new NameAst(l(yyStart), i);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.parenExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pparenExpr(final int yyStart) throws IOException {
    Result     yyResult;
    ExprAst    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLPAREN(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pexpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pRPAREN(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.listDisplay.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result plistDisplay(final int yyStart) throws IOException {
    Result        yyResult;
    int           yyRepetition1;
    Pair<ExprAst> yyRepValue1;
    ExprAst       yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLBRACKET(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pexpr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        ExprAst s = yyResult.semanticValue();

        yyResult = pFOR(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = ptype(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            TypeAst t = yyResult.semanticValue();

            yyResult = pid(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              NameAst i = yyResult.semanticValue();

              yyResult = pIN(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pexpr(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  ExprAst f = yyResult.semanticValue();

                  final int yyChoice2 = yyResult.index;

                  // Nested alternative 1.

                  yyResult = pIF(yyChoice2);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pexpr(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      ExprAst c = yyResult.semanticValue();

                      yyResult = pRBRACKET(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyValue=new ListForAst(l(yyStart), i, t, s, f, c);

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  }

                  // Nested alternative 2.

                  yyResult = pRBRACKET(yyChoice2);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyValue=new ListForAst(l(yyStart), i, t, s, f, null);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        }
      }

      // Nested alternative 2.

      yyResult = pexpr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        ExprAst h = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pCOMMA(yyRepetition1);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {

            yyResult = pexpr(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              ExprAst v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<ExprAst>(v$el$1, yyRepValue1);
              continue;
            }
          }
          break;
        }
        { // Start scope for t.
          Pair<ExprAst> t = yyRepValue1.reverse();

          yyResult = pRBRACKET(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue=new ListAst(l(yyStart),
            new Pair<ExprAst>(h, t).list().toArray(new ExprAst[0]));

            return yyResult.createValue(yyValue, yyError);
          }
        } // End scope for t.
      }

      // Nested alternative 3.

      yyResult = pRBRACKET(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue=new ListAst(l(yyStart), new ExprAst[0]);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.fragment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfragment(final int yyStart) throws IOException {
    Result     yyResult;
    Fragment   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcppFragment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = psqlFragment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.cppFragment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcppFragment(final int yyStart) throws IOException {
    int                      yyC;
    int                      yyIndex;
    Result                   yyResult;
    int                      yyBase;
    int                      yyRepetition1;
    Pair<AnnotationProperty> yyRepValue1;
    Fragment                 yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBACK_TICK(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('c' == yyC) {
        yyIndex = yyResult.index + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('p' == yyC) {
            yyIndex = yyIndex + 1;
            String l = "cpp";

            yyResult = pWS(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pLPAREN(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pphraseType(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  String p = yyResult.semanticValue();

                  yyRepetition1 = yyResult.index;
                  yyRepValue1   = Pair.empty();
                  while (true) {

                    yyResult = pCOMMA(yyRepetition1);
                    yyError  = yyResult.select(yyError, yyRepetition1);
                    if (yyResult.hasValue()) {

                      yyResult = pannotationProperty(yyResult.index);
                      yyError  = yyResult.select(yyError, yyRepetition1);
                      if (yyResult.hasValue()) {
                        AnnotationProperty v$el$1 = yyResult.semanticValue();

                        yyRepetition1 = yyResult.index;
                        yyRepValue1   = 
                          new Pair<AnnotationProperty>(v$el$1, yyRepValue1);
                        continue;
                      }
                    }
                    break;
                  }
                  { // Start scope for a.
                    Pair<AnnotationProperty> a = yyRepValue1.reverse();

                    yyResult = pRPAREN(yyRepetition1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pcppFragmentBody(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        FragmentBody b = yyResult.semanticValue();

                        yyBase = yyResult.index;

                        yyValue=makeFragment(l(yyStart), l, p, a.list(), b, l(yyBase));
                        yyResult=new SemanticValue(yyValue, yyBase);

                        yyError = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          yyValue = yyResult.semanticValue();
                          return yyResult.createValue(yyValue, yyError);
                        }
                      }
                    }
                  } // End scope for a.
                }
              }
            }
          } else {
            yyError = yyError.select("'cpp' expected", yyBase);
          }
        } else {
          yyError = yyError.select("'cpp' expected", yyBase);
        }
      } else {
        yyError = yyError.select("'cpp' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.sqlFragment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psqlFragment(final int yyStart) throws IOException {
    int                      yyC;
    int                      yyIndex;
    Result                   yyResult;
    int                      yyBase;
    int                      yyRepetition1;
    Pair<AnnotationProperty> yyRepValue1;
    Fragment                 yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBACK_TICK(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('s' == yyC) {
        yyIndex = yyResult.index + 1;

        yyC = character(yyIndex);
        if ('q' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('l' == yyC) {
            yyIndex = yyIndex + 1;
            String l = "sql";

            yyResult = pWS(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pLPAREN(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pphraseType(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  String p = yyResult.semanticValue();

                  yyRepetition1 = yyResult.index;
                  yyRepValue1   = Pair.empty();
                  while (true) {

                    yyResult = pCOMMA(yyRepetition1);
                    yyError  = yyResult.select(yyError, yyRepetition1);
                    if (yyResult.hasValue()) {

                      yyResult = pannotationProperty(yyResult.index);
                      yyError  = yyResult.select(yyError, yyRepetition1);
                      if (yyResult.hasValue()) {
                        AnnotationProperty v$el$1 = yyResult.semanticValue();

                        yyRepetition1 = yyResult.index;
                        yyRepValue1   = 
                          new Pair<AnnotationProperty>(v$el$1, yyRepValue1);
                        continue;
                      }
                    }
                    break;
                  }
                  { // Start scope for a.
                    Pair<AnnotationProperty> a = yyRepValue1.reverse();

                    yyResult = pRPAREN(yyRepetition1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = psqlFragmentBody(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        FragmentBody b = yyResult.semanticValue();

                        yyBase = yyResult.index;

                        yyValue=makeFragment(l(yyStart), l, p, a.list(), b, l(yyBase));
                        yyResult=new SemanticValue(yyValue, yyBase);

                        yyError = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          yyValue = yyResult.semanticValue();
                          return yyResult.createValue(yyValue, yyError);
                        }
                      }
                    }
                  } // End scope for a.
                }
              }
            }
          } else {
            yyError = yyError.select("'sql' expected", yyBase);
          }
        } else {
          yyError = yyError.select("'sql' expected", yyBase);
        }
      } else {
        yyError = yyError.select("'sql' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.annotationProperty.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pannotationProperty(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fannotationProperty) 
      yyColumn.chunk3.fannotationProperty = pannotationProperty$1(yyStart);
    return yyColumn.chunk3.fannotationProperty;
  }

  /** Actually parse Marco.annotationProperty. */
  private Result pannotationProperty$1(final int yyStart) throws IOException {
    Result             yyResult;
    AnnotationProperty yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pID(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String i = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pASSIGN(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pLBRACKET(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pnameList(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Object n = yyResult.semanticValue();

            yyResult = pRBRACKET(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue=new AnnotationProperty(i, n);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }

      // Nested alternative 2.

      yyValue=new AnnotationProperty(i, null);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.nameList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pnameList(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyRepetition1;
    Pair<String> yyRepValue1;
    Object       yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcaptuableName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String h = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCOMMA(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {

          yyResult = pcaptuableName(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            String v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for t.
        Pair<String> t = yyRepValue1.reverse();

        yyValue=new Pair<String>(h, t).list().toArray(new String[0]);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for t.
    }

    // Alternative 2.

    yyValue=new String[0];

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.captuableName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcaptuableName(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fcaptuableName) 
      yyColumn.chunk3.fcaptuableName = pcaptuableName$1(yyStart);
    return yyColumn.chunk3.fcaptuableName;
  }

  /** Actually parse Marco.captuableName. */
  private Result pcaptuableName$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pID(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pID_KEYWORD(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue="id";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.fragmentLanguage.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfragmentLanguage(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pID(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.phraseType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pphraseType(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fphraseType) 
      yyColumn.chunk4.fphraseType = pphraseType$1(yyStart);
    return yyColumn.chunk4.fphraseType;
  }

  /** Actually parse Marco.phraseType. */
  private Result pphraseType$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pID(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pID_KEYWORD(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue="id";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pTYPE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue="type";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.cppFragmentBody.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcppFragmentBody(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fcppFragmentBody) 
      yyColumn.chunk4.fcppFragmentBody = pcppFragmentBody$1(yyStart);
    return yyColumn.chunk4.fcppFragmentBody;
  }

  /** Actually parse Marco.cppFragmentBody. */
  private Result pcppFragmentBody$1(final int yyStart) throws IOException {
    Result       yyResult;
    FragmentBody yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLBRACKET(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcppFragmentBody$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<FragmentElement> f = yyResult.semanticValue();

        yyResult = pRBRACKET(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue=new FragmentBody(l(yyStart), f.list());

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Marco.cppFragmentBody$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcppFragmentBody$$Star1(final int yyStart) 
    throws IOException {

    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fcppFragmentBody$$Star1) 
      yyColumn.chunk4.fcppFragmentBody$$Star1 = pcppFragmentBody$$Star1$1(yyStart);
    return yyColumn.chunk4.fcppFragmentBody$$Star1;
  }

  /** Actually parse Marco.cppFragmentBody$$Star1. */
  private Result pcppFragmentBody$$Star1$1(final int yyStart) 
    throws IOException {

    Result                yyResult;
    Pair<FragmentElement> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcppFragmentElement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      FragmentElement v$el$1 = yyResult.semanticValue();

      yyResult = pcppFragmentBody$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<FragmentElement> v$2 = yyResult.semanticValue();

        yyValue = new Pair<FragmentElement>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.cppFragmentElement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcppFragmentElement(final int yyStart) throws IOException {
    Result          yyResult;
    FragmentElement yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcppFragmentBody(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pcppId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pcppKeyword(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pcppLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = p$$Shared1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pcppOther(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.cppId.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcppId(final int yyStart) throws IOException {
    Result     yyResult;
    ObjectId   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pID_INTERNAL(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String i = yyResult.semanticValue();

      yyResult = pCPP_WS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        if (!CPP_KEYWORDS.contains(i)) {

          yyValue=new ObjectId(l(yyStart), i);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("cpp id expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.cppKeyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcppKeyword(final int yyStart) throws IOException {
    Result      yyResult;
    ObjectToken yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pID_INTERNAL(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String i = yyResult.semanticValue();

      yyResult = pCPP_WS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        if (CPP_KEYWORDS.contains(i)) {

          yyValue=new ObjectToken(l(yyStart), i, false, false);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("cpp keyword expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.cppLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcppLiteral(final int yyStart) throws IOException {
    Result      yyResult;
    ObjectToken yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCPP_FLOATLIT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String l = yyResult.semanticValue();

      yyResult = pCPP_WS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue=new ObjectToken(l(yyStart),l,false,false);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = p$$Shared2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String l = yyResult.semanticValue();

      yyResult = pCPP_WS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue=new ObjectToken(l(yyStart),l,false,false);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = p$$Shared3(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String l = yyResult.semanticValue();

      yyResult = pCPP_WS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue=new ObjectToken(l(yyStart),l,true, false);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyResult = pCPP_CHARLIT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String l = yyResult.semanticValue();

      yyResult = pCPP_WS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue=new ObjectToken(l(yyStart),l,false,true );

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Marco.$$Shared1.
   * This nonterminal represents the duplicate productions Marco.cppBlank 
   * and Marco.sqlBlank.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared1(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.f$$Shared1) 
      yyColumn.chunk4.f$$Shared1 = p$$Shared1$1(yyStart);
    return yyColumn.chunk4.f$$Shared1;
  }

  /** Actually parse Marco.$$Shared1. */
  private Result p$$Shared1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Blank      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDOLLAR(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pid(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        NameAst i = yyResult.semanticValue();

        yyValue=new Blank(l(yyStart), i);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pLBRACKET(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pexpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          ExprAst e = yyResult.semanticValue();

          yyResult = pRBRACKET(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue=new Blank(l(yyStart), e);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.cppOther.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcppOther(final int yyStart) throws IOException {
    Result      yyResult;
    ObjectToken yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared4(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String t = yyResult.semanticValue();

      yyResult = pCPP_WS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue=new ObjectToken(l(yyStart), t, false, false);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.CPP_FLOATLIT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCPP_FLOATLIT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    int        yyOption1;
    int        yyOption2;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCPP_FLOATLIT$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;

      yyC = character(yyOption1);
      if (-1 != yyC) {
        yyIndex = yyOption1 + 1;

        switch (yyC) {
        case 'E':
        case 'e':
          {
            yyOption2  = yyIndex;

            final int yyChoice1 = yyOption2;

            // Nested alternative 1.

            yyC = character(yyChoice1);
            if (-1 != yyC) {
              yyIndex = yyChoice1 + 1;

              switch (yyC) {
              case '+':
                {
                  yyOption2  = yyIndex;
                }
                break;

              case '-':
                {
                  yyOption2  = yyIndex;
                }
                break;

              default:
                /* No match. */
              }
            }

            yyRepetition1 = yyOption2;
            yyRepeated1   = false;
            while (true) {

              yyC = character(yyRepetition1);
              if (-1 != yyC) {
                yyIndex = yyRepetition1 + 1;

                switch (yyC) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                  {
                    yyRepetition1 = yyIndex;
                    yyRepeated1   = true;
                    continue;
                  }

                default:
                  /* No match. */
                }
              }
              break;
            }

            if (yyRepeated1) {

              yyOption1  = yyRepetition1;
            }
          }
          break;

        default:
          /* No match. */
        }
      }


      yyC = character(yyOption1);
      if (-1 != yyC) {
        yyIndex = yyOption1 + 1;

        switch (yyC) {
        case 'F':
        case 'L':
        case 'f':
        case 'l':
          {
            yyOption1  = yyIndex;
          }
          break;

        default:
          /* No match. */
        }
      }

      yyValue = difference(yyStart, yyOption1);

      return new SemanticValue(yyValue, yyOption1, yyError);
    }

    // Done.
    yyError = yyError.select("c p p_ f l o a t l i t expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Marco.CPP_FLOATLIT$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCPP_FLOATLIT$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    yyBase = yyRepetition1;
    yyC    = character(yyBase);
    if ('.' == yyC) {
      yyIndex = yyRepetition1 + 1;

      yyRepetition1 = yyIndex;
      yyRepeated1   = false;
      while (true) {

        yyC = character(yyRepetition1);
        if (-1 != yyC) {
          yyIndex = yyRepetition1 + 1;

          switch (yyC) {
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            {
              yyRepetition1 = yyIndex;
              yyRepeated1   = true;
              continue;
            }

          default:
            /* No match. */
          }
        }
        break;
      }

      if (yyRepeated1) {

        yyValue = null;

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    } else {
      yyError = yyError.select("'.' expected", yyBase);
    }

    // Alternative 2.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyBase = yyRepetition1;
      yyC    = character(yyBase);
      if ('.' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("'.' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("c p p_ f l o a t l i t expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Marco.$$Shared2.
   * This nonterminal represents the duplicate productions Marco.CPP_INTLIT, 
   * Marco.SQL_INTLIT, and Marco.INTLIT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared2(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.f$$Shared2) 
      yyColumn.chunk4.f$$Shared2 = p$$Shared2$1(yyStart);
    return yyColumn.chunk4.f$$Shared2;
  }

  /** Actually parse Marco.$$Shared2. */
  private Result p$$Shared2$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyResult = p$$Shared2(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = difference(yyStart, yyResult.index);

            return yyResult.createValue(yyValue, yyError);
          }

          // Nested alternative 2.

          yyValue = difference(yyStart, yyChoice1);

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Marco.$$Shared3.
   * This nonterminal represents the duplicate productions 
   * Marco.CPP_STRINGLIT and Marco.STRINGLIT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared3(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.f$$Shared3) 
      yyColumn.chunk4.f$$Shared3 = p$$Shared3$1(yyStart);
    return yyColumn.chunk4.f$$Shared3;
  }

  /** Actually parse Marco.$$Shared3. */
  private Result p$$Shared3$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\"' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = p$$Shared3$$Star1(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyC = character(yyResult.index);
        if ('\"' == yyC) {
          yyIndex = yyResult.index + 1;

          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Marco.$$Shared3$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared3$$Star1(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.f$$Shared3$$Star1) 
      yyColumn.chunk4.f$$Shared3$$Star1 = p$$Shared3$$Star1$1(yyStart);
    return yyColumn.chunk4.f$$Shared3$$Star1;
  }

  /** Actually parse Marco.$$Shared3$$Star1. */
  private Result p$$Shared3$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\\':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '\"':
            case '\'':
            case 'n':
            case 'r':
            case 't':
              {
                yyResult = p$$Shared3$$Star1(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = null;

                  return yyResult.createValue(yyValue, yyError);
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\n':
      case '\r':
      case '\"':
      case '\\':
        /* No match. */
        break;

      default:
        {
          yyResult = p$$Shared3$$Star1(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 3.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.CPP_CHARLIT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCPP_CHARLIT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\'' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pCPP_CHARLIT$$Choice1(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if ('\'' == yyC) {
          yyIndex = yyResult.index + 1;

          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("'\\\'' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("c p p_ c h a r l i t expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Marco.CPP_CHARLIT$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCPP_CHARLIT$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\\':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '\'':
            case 'n':
            case 'r':
            case 't':
              {
                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\n':
      case '\r':
      case '\'':
      case '\\':
        /* No match. */
        break;

      default:
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("c p p_ c h a r l i t expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Marco.$$Shared4.
   * This nonterminal represents the duplicate productions Marco.CPP_OTHER 
   * and Marco.SQL_OTHER.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared4(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.f$$Shared4) 
      yyColumn.chunk4.f$$Shared4 = p$$Shared4$1(yyStart);
    return yyColumn.chunk4.f$$Shared4;
  }

  /** Actually parse Marco.$$Shared4. */
  private Result p$$Shared4$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = p$$Shared4$$Choice1(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;

        final int yyChoice1 = yyIndex;

        // Nested alternative 1.

        yyResult = p$$Shared4(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyValue = difference(yyStart, yyChoice1);

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    } else {
      yyError = yyError.select(" expected", yyStart);
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Marco.$$Shared4$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared4$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '[':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ']':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          ('_' == yyC) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\"':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\'':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '$':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\t':
      case '\n':
      case '\r':
      case ' ':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.CPP_WS.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCPP_WS(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fCPP_WS) 
      yyColumn.chunk4.fCPP_WS = pCPP_WS$1(yyStart);
    return yyColumn.chunk4.fCPP_WS;
  }

  /** Actually parse Marco.CPP_WS. */
  private Result pCPP_WS$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\t':
      case ' ':
        {
          yyResult = pCPP_WS(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyResult = pNEWLINE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pCPP_WS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pCPP_COMMENT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pCPP_WS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.CPP_COMMENT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCPP_COMMENT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ('/' == yyC) {

        yyC = character(yyIndex);
        if (-1 != yyC) {
          yyIndex = yyIndex + 1;

          switch (yyC) {
          case '/':
            {
              yyRepetition1 = yyIndex;
              while (true) {

                yyC = character(yyRepetition1);
                if (-1 != yyC) {
                  yyIndex = yyRepetition1 + 1;

                  switch (yyC) {
                  case '\n':
                  case '\r':
                    /* No match. */
                    break;

                  default:
                    {
                      yyRepetition1 = yyIndex;
                      continue;
                    }
                  }
                }
                break;
              }

              final int yyChoice1 = yyRepetition1;

              // Nested alternative 1.

              yyResult = pNEWLINE(yyChoice1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = null;

                return yyResult.createValue(yyValue, yyError);
              }

              // Nested alternative 2.

              yyPredResult = pEOF(yyChoice1);
              yyError      = yyPredResult.select(yyError);
              if (yyPredResult.hasValue()) {

                yyValue = null;

                return new SemanticValue(yyValue, yyChoice1, yyError);
              }
            }
            break;

          case '*':
            {
              yyRepetition1 = yyIndex;
              while (true) {

                final int yyChoice1 = yyRepetition1;

                // Nested alternative 1.

                yyBase = yyChoice1;
                yyC    = character(yyBase);
                if ('*' == yyC) {
                  yyIndex = yyChoice1 + 1;

                  yyPredMatched = false;

                  yyC = character(yyIndex);
                  if ('/' == yyC) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyRepetition1 = yyIndex;
                    continue;
                  } else {
                    yyError = yyError.select("c p p_ c o m m e n t expected", yyStart);
                  }
                } else {
                  yyError = yyError.select("'*' expected", yyBase);
                }

                // Nested alternative 2.

                yyPredMatched = false;

                yyC = character(yyChoice1);
                if ('*' == yyC) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyC = character(yyChoice1);
                  if (-1 != yyC) {
                    yyIndex = yyChoice1 + 1;

                    yyRepetition1 = yyIndex;
                    continue;
                  }
                } else {
                  yyError = yyError.select("c p p_ c o m m e n t expected", yyStart);
                }
                break;
              }

              yyBase = yyRepetition1;
              yyC    = character(yyBase);
              if ('*' == yyC) {
                yyIndex = yyRepetition1 + 1;

                yyC = character(yyIndex);
                if ('/' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("'*/' expected", yyBase);
                }
              } else {
                yyError = yyError.select("'*/' expected", yyBase);
              }
            }
            break;

          default:
            /* No match. */
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("c p p_ c o m m e n t expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.sqlFragmentBody.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psqlFragmentBody(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fsqlFragmentBody) 
      yyColumn.chunk4.fsqlFragmentBody = psqlFragmentBody$1(yyStart);
    return yyColumn.chunk4.fsqlFragmentBody;
  }

  /** Actually parse Marco.sqlFragmentBody. */
  private Result psqlFragmentBody$1(final int yyStart) throws IOException {
    Result       yyResult;
    FragmentBody yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLBRACKET(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = psqlFragmentBody$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<FragmentElement> f = yyResult.semanticValue();

        yyResult = pRBRACKET(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue=new FragmentBody(l(yyStart), f.list());

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Marco.sqlFragmentBody$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psqlFragmentBody$$Star1(final int yyStart) 
    throws IOException {

    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fsqlFragmentBody$$Star1) 
      yyColumn.chunk5.fsqlFragmentBody$$Star1 = psqlFragmentBody$$Star1$1(yyStart);
    return yyColumn.chunk5.fsqlFragmentBody$$Star1;
  }

  /** Actually parse Marco.sqlFragmentBody$$Star1. */
  private Result psqlFragmentBody$$Star1$1(final int yyStart) 
    throws IOException {

    Result                yyResult;
    Pair<FragmentElement> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psqlFragmentElement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      FragmentElement v$el$1 = yyResult.semanticValue();

      yyResult = psqlFragmentBody$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<FragmentElement> v$2 = yyResult.semanticValue();

        yyValue = new Pair<FragmentElement>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.sqlFragmentElement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psqlFragmentElement(final int yyStart) throws IOException {
    Result          yyResult;
    FragmentElement yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psqlFragmentBody(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = psqlId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = psqlKeyword(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = psqlLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = p$$Shared1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = psqlOther(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.sqlId.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psqlId(final int yyStart) throws IOException {
    Result     yyResult;
    ObjectId   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pID_INTERNAL(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String i = yyResult.semanticValue();

      yyResult = pSQL_WS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        if (!SQL_KEYWORDS.contains(i.toLowerCase())) {

          yyValue=new ObjectId(l(yyStart), i);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pSQL_QUOTEDID(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String i = yyResult.semanticValue();

      yyResult = pSQL_WS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue=new ObjectId(l(yyStart), i);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("sql id expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.sqlKeyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psqlKeyword(final int yyStart) throws IOException {
    Result      yyResult;
    ObjectToken yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pID_INTERNAL(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String i = yyResult.semanticValue();

      yyResult = pSQL_WS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        if (SQL_KEYWORDS.contains(i.toLowerCase())) {

          yyValue=new ObjectToken(l(yyStart), i, false, false);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("sql keyword expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.sqlLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psqlLiteral(final int yyStart) throws IOException {
    Result      yyResult;
    ObjectToken yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSQL_FLOATLIT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String l = yyResult.semanticValue();

      yyResult = pSQL_WS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue=new ObjectToken(l(yyStart),l,false,false);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = p$$Shared2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String l = yyResult.semanticValue();

      yyResult = pSQL_WS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue=new ObjectToken(l(yyStart),l,false,false);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pSQL_STRINGLIT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String l = yyResult.semanticValue();

      yyResult = pSQL_WS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue=new ObjectToken(l(yyStart),l,true, false);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.sqlOther.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psqlOther(final int yyStart) throws IOException {
    Result      yyResult;
    ObjectToken yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared4(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String t = yyResult.semanticValue();

      yyResult = pSQL_WS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue=new ObjectToken(l(yyStart), t, false, false);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.SQL_FLOATLIT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSQL_FLOATLIT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyBase = yyRepetition1;
      yyC    = character(yyBase);
      if ('.' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyRepetition1 = yyIndex;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;

            switch (yyC) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
              {
                yyRepetition1 = yyIndex;
                continue;
              }

            default:
              /* No match. */
            }
          }
          break;
        }

        yyValue = difference(yyStart, yyRepetition1);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } else {
        yyError = yyError.select("'.' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("s q l_ f l o a t l i t expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.SQL_STRINGLIT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSQL_STRINGLIT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyBase;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\'' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      while (true) {

        final int yyChoice1 = yyRepetition1;

        // Nested alternative 1.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case '\\':
            {
              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;

                switch (yyC) {
                case '\"':
                case '\'':
                case 'n':
                case 'r':
                case 't':
                  {
                    yyRepetition1 = yyIndex;
                    continue;
                  }

                default:
                  /* No match. */
                }
              }
            }
            break;

          default:
            /* No match. */
          }
        }

        // Nested alternative 2.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case '\n':
          case '\r':
          case '\"':
          case '\\':
            /* No match. */
            break;

          default:
            {
              yyRepetition1 = yyIndex;
              continue;
            }
          }
        }
        break;
      }

      yyBase = yyRepetition1;
      yyC    = character(yyBase);
      if ('\'' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("'\\\'' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("s q l_ s t r i n g l i t expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.SQL_QUOTEDID.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSQL_QUOTEDID(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\"' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      yyRepeated1   = false;
      while (true) {

        yyC = character(yyRepetition1);
        if (-1 != yyC) {
          yyIndex = yyRepetition1 + 1;
          if ((('0' <= yyC) && (yyC <= '9')) ||
              (('A' <= yyC) && (yyC <= 'Z')) ||
              ('_' == yyC) ||
              (('a' <= yyC) && (yyC <= 'z'))) {

            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }
        }
        break;
      }

      if (yyRepeated1) {

        yyC = character(yyRepetition1);
        if ('\"' == yyC) {
          yyIndex = yyRepetition1 + 1;

          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("s q l_ q u o t e d i d expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.SQL_WS.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSQL_WS(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fSQL_WS) 
      yyColumn.chunk5.fSQL_WS = pSQL_WS$1(yyStart);
    return yyColumn.chunk5.fSQL_WS;
  }

  /** Actually parse Marco.SQL_WS. */
  private Result pSQL_WS$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\t':
      case ' ':
        {
          yyResult = pSQL_WS(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyResult = pNEWLINE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pSQL_WS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pSQL_COMMENT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pSQL_WS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.SQL_COMMENT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSQL_COMMENT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '-':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('-' == yyC) {

              yyRepetition1 = yyIndex;
              while (true) {

                yyC = character(yyRepetition1);
                if (-1 != yyC) {
                  yyIndex = yyRepetition1 + 1;

                  switch (yyC) {
                  case '\n':
                  case '\r':
                    /* No match. */
                    break;

                  default:
                    {
                      yyRepetition1 = yyIndex;
                      continue;
                    }
                  }
                }
                break;
              }

              final int yyChoice1 = yyRepetition1;

              // Nested alternative 1.

              yyResult = pNEWLINE(yyChoice1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = null;

                return yyResult.createValue(yyValue, yyError);
              }

              // Nested alternative 2.

              yyPredResult = pEOF(yyChoice1);
              yyError      = yyPredResult.select(yyError);
              if (yyPredResult.hasValue()) {

                yyValue = null;

                return new SemanticValue(yyValue, yyChoice1, yyError);
              }
            }
          }
        }
        break;

      case '/':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('*' == yyC) {

              yyRepetition1 = yyIndex;
              while (true) {

                final int yyChoice1 = yyRepetition1;

                // Nested alternative 1.

                yyBase = yyChoice1;
                yyC    = character(yyBase);
                if ('*' == yyC) {
                  yyIndex = yyChoice1 + 1;

                  yyPredMatched = false;

                  yyC = character(yyIndex);
                  if ('/' == yyC) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyRepetition1 = yyIndex;
                    continue;
                  } else {
                    yyError = yyError.select("s q l_ c o m m e n t expected", yyStart);
                  }
                } else {
                  yyError = yyError.select("'*' expected", yyBase);
                }

                // Nested alternative 2.

                yyPredMatched = false;

                yyC = character(yyChoice1);
                if ('*' == yyC) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyC = character(yyChoice1);
                  if (-1 != yyC) {
                    yyIndex = yyChoice1 + 1;

                    yyRepetition1 = yyIndex;
                    continue;
                  }
                } else {
                  yyError = yyError.select("s q l_ c o m m e n t expected", yyStart);
                }
                break;
              }

              yyBase = yyRepetition1;
              yyC    = character(yyBase);
              if ('*' == yyC) {
                yyIndex = yyRepetition1 + 1;

                yyC = character(yyIndex);
                if ('/' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("'*/' expected", yyBase);
                }
              } else {
                yyError = yyError.select("'*/' expected", yyBase);
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("s q l_ c o m m e n t expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.ASSERT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pASSERT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('s' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyResult = pWS(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = null;

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("ASSERT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.BOOLEAN.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBOOLEAN(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('b' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('o' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('l' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('a' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('n' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyResult = pWS(yyIndex);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyValue = null;

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("BOOLEAN expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.CODE.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCODE(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('C' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('d' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyResult = pWS(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = null;

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("CODE expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.CONST.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCONST(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('n' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('s' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('t' == yyC) {
              yyIndex = yyIndex + 1;

              yyResult = pWS(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = null;

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("CONST expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.DOUBLE.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDOUBLE(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('u' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('b' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('l' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyResult = pWS(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = null;

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("DOUBLE expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.ELSE.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pELSE(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('l' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyResult = pWS(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = null;

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("ELSE expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.EXTERN.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEXTERN(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('x' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyResult = pWS(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = null;

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("EXTERN expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.FALSE.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFALSE(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('s' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyResult = pWS(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = null;

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("FALSE expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.FOR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFOR(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fFOR) yyColumn.chunk5.fFOR = pFOR$1(yyStart);
    return yyColumn.chunk5.fFOR;
  }

  /** Actually parse Marco.FOR. */
  private Result pFOR$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyResult = pWS(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("FOR expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.ID_KEYWORD.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pID_KEYWORD(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fID_KEYWORD) 
      yyColumn.chunk5.fID_KEYWORD = pID_KEYWORD$1(yyStart);
    return yyColumn.chunk5.fID_KEYWORD;
  }

  /** Actually parse Marco.ID_KEYWORD. */
  private Result pID_KEYWORD$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('d' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pWS(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("i d_ k e y w o r d expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.IF.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIF(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fIF) yyColumn.chunk5.fIF = pIF$1(yyStart);
    return yyColumn.chunk5.fIF;
  }

  /** Actually parse Marco.IF. */
  private Result pIF$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('f' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pWS(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("IF expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.IMPORT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIMPORT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('m' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('o' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyResult = pWS(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = null;

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("IMPORT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.IN.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIN(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fIN) yyColumn.chunk5.fIN = pIN$1(yyStart);
    return yyColumn.chunk5.fIN;
  }

  /** Actually parse Marco.IN. */
  private Result pIN$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pWS(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("IN expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.INT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pINT(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fINT) yyColumn.chunk5.fINT = pINT$1(yyStart);
    return yyColumn.chunk5.fINT;
  }

  /** Actually parse Marco.INT. */
  private Result pINT$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyResult = pWS(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("INT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.LIST.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLIST(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('l' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyResult = pWS(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = null;

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("LIST expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.RETURN.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRETURN(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('r' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('u' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyResult = pWS(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = null;

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("RETURN expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.STRING.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSTRING(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('t' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('i' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('n' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('g' == yyC) {
                yyIndex = yyIndex + 1;

                yyResult = pWS(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = null;

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("STRING expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.TUPLE.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTUPLE(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('u' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('l' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyResult = pWS(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = null;

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("TUPLE expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.TRUE.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTRUE(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('u' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyResult = pWS(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = null;

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("TRUE expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.TYPE.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTYPE(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fTYPE) 
      yyColumn.chunk5.fTYPE = pTYPE$1(yyStart);
    return yyColumn.chunk5.fTYPE;
  }

  /** Actually parse Marco.TYPE. */
  private Result pTYPE$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('y' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyResult = pWS(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = null;

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("TYPE expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.VOID.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVOID(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('v' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('d' == yyC) {
            yyIndex = yyIndex + 1;

            yyResult = pWS(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = null;

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("VOID expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.WITH.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWITH(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('w' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('h' == yyC) {
            yyIndex = yyIndex + 1;

            yyResult = pWS(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = null;

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("WITH expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.ASSIGN.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pASSIGN(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fASSIGN) 
      yyColumn.chunk5.fASSIGN = pASSIGN$1(yyStart);
    return yyColumn.chunk5.fASSIGN;
  }

  /** Actually parse Marco.ASSIGN. */
  private Result pASSIGN$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pWS(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("ASSIGN expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.ASSIGN_PLUS.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pASSIGN_PLUS(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('+' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pWS(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("a s s i g n_ p l u s expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.BACK_TICK.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBACK_TICK(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fBACK_TICK) 
      yyColumn.chunk5.fBACK_TICK = pBACK_TICK$1(yyStart);
    return yyColumn.chunk5.fBACK_TICK;
  }

  /** Actually parse Marco.BACK_TICK. */
  private Result pBACK_TICK$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('`' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pWS(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("b a c k_ t i c k expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.BIT_AND.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBIT_AND(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('&' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pWS(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("b i t_ a n d expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.BIT_OR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBIT_OR(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pWS(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("b i t_ o r expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.BIT_XOR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBIT_XOR(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('^' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pWS(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("b i t_ x o r expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.COLON.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCOLON(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pWS(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("COLON expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.COMMA.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCOMMA(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fCOMMA) 
      yyColumn.chunk6.fCOMMA = pCOMMA$1(yyStart);
    return yyColumn.chunk6.fCOMMA;
  }

  /** Actually parse Marco.COMMA. */
  private Result pCOMMA$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pWS(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("COMMA expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.DIVIDE.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDIVIDE(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pWS(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("DIVIDE expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.DOLLAR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDOLLAR(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('$' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pWS(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("DOLLAR expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.DOT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDOT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('.' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pWS(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("DOT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.EQUAL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEQUAL(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pWS(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("EQUAL expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.GREATER.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGREATER(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fGREATER) 
      yyColumn.chunk6.fGREATER = pGREATER$1(yyStart);
    return yyColumn.chunk6.fGREATER;
  }

  /** Actually parse Marco.GREATER. */
  private Result pGREATER$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pWS(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("GREATER expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.GREATER_EQUAL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGREATER_EQUAL(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pWS(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("g r e a t e r_ e q u a l expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.LBRACE.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLBRACE(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('{' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pWS(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("LBRACE expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.LBRACKET.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLBRACKET(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fLBRACKET) 
      yyColumn.chunk6.fLBRACKET = pLBRACKET$1(yyStart);
    return yyColumn.chunk6.fLBRACKET;
  }

  /** Actually parse Marco.LBRACKET. */
  private Result pLBRACKET$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('[' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pWS(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("LBRACKET expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.LESS.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLESS(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fLESS) 
      yyColumn.chunk6.fLESS = pLESS$1(yyStart);
    return yyColumn.chunk6.fLESS;
  }

  /** Actually parse Marco.LESS. */
  private Result pLESS$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pWS(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("LESS expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.LESS_EQUAL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLESS_EQUAL(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pWS(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("l e s s_ e q u a l expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.LOGICAL_AND.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLOGICAL_AND(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('&' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('&' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pWS(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("l o g i c a l_ a n d expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.LOGICAL_OR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLOGICAL_OR(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('|' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pWS(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("l o g i c a l_ o r expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.LOGICAL_NOT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLOGICAL_NOT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('!' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pWS(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("l o g i c a l_ n o t expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.LPAREN.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLPAREN(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fLPAREN) 
      yyColumn.chunk6.fLPAREN = pLPAREN$1(yyStart);
    return yyColumn.chunk6.fLPAREN;
  }

  /** Actually parse Marco.LPAREN. */
  private Result pLPAREN$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pWS(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("LPAREN expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.LSHIFT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLSHIFT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('<' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pWS(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("LSHIFT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.MINUS.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMINUS(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pWS(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("MINUS expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.MULT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMULT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pWS(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("MULT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.NOT_EQUAL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNOT_EQUAL(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('!' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pWS(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("n o t_ e q u a l expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.PERCENT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPERCENT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('%' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pWS(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("PERCENT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.PLUS.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPLUS(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('+' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pWS(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("PLUS expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.RBRACE.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRBRACE(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('}' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pWS(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("RBRACE expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.RBRACKET.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRBRACKET(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fRBRACKET) 
      yyColumn.chunk6.fRBRACKET = pRBRACKET$1(yyStart);
    return yyColumn.chunk6.fRBRACKET;
  }

  /** Actually parse Marco.RBRACKET. */
  private Result pRBRACKET$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (']' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pWS(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("RBRACKET expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.RPAREN.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRPAREN(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fRPAREN) 
      yyColumn.chunk6.fRPAREN = pRPAREN$1(yyStart);
    return yyColumn.chunk6.fRPAREN;
  }

  /** Actually parse Marco.RPAREN. */
  private Result pRPAREN$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (')' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pWS(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("RPAREN expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.RSHIFT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRSHIFT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pWS(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("RSHIFT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.SEMI.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSEMI(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fSEMI) 
      yyColumn.chunk6.fSEMI = pSEMI$1(yyStart);
    return yyColumn.chunk6.fSEMI;
  }

  /** Actually parse Marco.SEMI. */
  private Result pSEMI$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (';' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pWS(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("SEMI expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.ID.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pID(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fID) yyColumn.chunk6.fID = pID$1(yyStart);
    return yyColumn.chunk6.fID;
  }

  /** Actually parse Marco.ID. */
  private Result pID$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pID_INTERNAL(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String i = yyResult.semanticValue();

      yyResult = pWS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        if (!MARCO_KEYWORDS.contains(i)) {

          yyValue = i;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("ID expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.ID_INTERNAL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pID_INTERNAL(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fID_INTERNAL) 
      yyColumn.chunk6.fID_INTERNAL = pID_INTERNAL$1(yyStart);
    return yyColumn.chunk6.fID_INTERNAL;
  }

  /** Actually parse Marco.ID_INTERNAL. */
  private Result pID_INTERNAL$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          ('_' == yyC) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyResult = pID_INTERNAL$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("i d_ i n t e r n a l expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Marco.ID_INTERNAL$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pID_INTERNAL$$Star1(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fID_INTERNAL$$Star1) 
      yyColumn.chunk7.fID_INTERNAL$$Star1 = pID_INTERNAL$$Star1$1(yyStart);
    return yyColumn.chunk7.fID_INTERNAL$$Star1;
  }

  /** Actually parse Marco.ID_INTERNAL$$Star1. */
  private Result pID_INTERNAL$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('0' <= yyC) && (yyC <= '9')) ||
          (('A' <= yyC) && (yyC <= 'Z')) ||
          ('_' == yyC) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyResult = pID_INTERNAL$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.WS.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWS(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fWS) yyColumn.chunk7.fWS = pWS$1(yyStart);
    return yyColumn.chunk7.fWS;
  }

  /** Actually parse Marco.WS. */
  private Result pWS$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\t':
      case ' ':
        {
          yyResult = pWS(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyResult = pNEWLINE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pWS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pCOMMENT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pWS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.NEWLINE.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNEWLINE(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fNEWLINE) 
      yyColumn.chunk7.fNEWLINE = pNEWLINE$1(yyStart);
    return yyColumn.chunk7.fNEWLINE;
  }

  /** Actually parse Marco.NEWLINE. */
  private Result pNEWLINE$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\r':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if ('\n' == yyC) {
            yyIndex = yyChoice1 + 1;

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '\n':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("NEWLINE expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.COMMENT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCOMMENT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCOMMENT$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyRepetition1 = yyResult.index;
      while (true) {

        yyC = character(yyRepetition1);
        if (-1 != yyC) {
          yyIndex = yyRepetition1 + 1;

          switch (yyC) {
          case '\n':
          case '\r':
            /* No match. */
            break;

          default:
            {
              yyRepetition1 = yyIndex;
              continue;
            }
          }
        }
        break;
      }

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyResult = pNEWLINE(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyPredResult = pEOF(yyChoice1);
      yyError      = yyPredResult.select(yyError);
      if (yyPredResult.hasValue()) {

        yyValue = null;

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;

        yyRepetition1 = yyIndex;
        while (true) {

          final int yyChoice1 = yyRepetition1;

          // Nested alternative 1.

          yyBase = yyChoice1;
          yyC    = character(yyBase);
          if ('*' == yyC) {
            yyIndex = yyChoice1 + 1;

            yyPredMatched = false;

            yyC = character(yyIndex);
            if ('/' == yyC) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyRepetition1 = yyIndex;
              continue;
            } else {
              yyError = yyError.select("COMMENT expected", yyStart);
            }
          } else {
            yyError = yyError.select("'*' expected", yyBase);
          }

          // Nested alternative 2.

          yyPredMatched = false;

          yyC = character(yyChoice1);
          if ('*' == yyC) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyC = character(yyChoice1);
            if (-1 != yyC) {
              yyIndex = yyChoice1 + 1;

              yyRepetition1 = yyIndex;
              continue;
            }
          } else {
            yyError = yyError.select("COMMENT expected", yyStart);
          }
          break;
        }

        yyBase = yyRepetition1;
        yyC    = character(yyBase);
        if ('*' == yyC) {
          yyIndex = yyRepetition1 + 1;

          yyC = character(yyIndex);
          if ('/' == yyC) {
            yyIndex = yyIndex + 1;

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("'*/' expected", yyBase);
          }
        } else {
          yyError = yyError.select("'*/' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("COMMENT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Marco.COMMENT$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCOMMENT$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '#':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '/':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('/' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("COMMENT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Marco.EOF.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEOF(final int yyStart) throws IOException {
    RatsMarcoParserColumn yyColumn = (RatsMarcoParserColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fEOF) yyColumn.chunk7.fEOF = pEOF$1(yyStart);
    return yyColumn.chunk7.fEOF;
  }

  /** Actually parse Marco.EOF. */
  private Result pEOF$1(final int yyStart) throws IOException {
    int        yyC;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if (-1 != yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyValue = null;

      return new SemanticValue(yyValue, yyStart, yyError);
    } else {
      yyError = yyError.select("EOF expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  public static final Set<String> MARCO_KEYWORDS =
  new HashSet<String>(Arrays.asList("assert", "boolean", "Code", "const", "double", "else", "extern", "false", "for", "id", "if", "in", "import", "int", "list", "return", "set", "string", "true", "tuple", "type", "void", "with"));
  
  public static final Set<String> CPP_KEYWORDS =
  new HashSet<String>(Arrays.asList("and", "and_eq", "alignas", "alignof", "asm", "auto", "bitand", "bitor", "bool", "break", "case", "catch", "char", "char16_t", "char32_t", "class", "compl", "const", "constexpr", "const_cast", "continue", "decltype", "default", "delete", "double", "dynamic_cast", "else", "enum", "explicit", "export", "extern", "false", "float", "for", "friend", "goto", "if", "inline", "int", "long", "mutable", "namespace", "new", "noexcept", "not", "not_eq", "nullptr", "operator", "or", "or_eq", "private", "protected", "public", "register", "reinterpret_cast", "return", "short", "signed", "sizeof", "static", "static_assert", "static_cast", "struct", "switch", "template", "this", "thread_local", "throw", "true", "try", "typedef", "typeid", "typename", "union", "unsigned", "using", "virtual", "void", "volatile", "wchar_t", "while", "xor", "xor_eq"));
  
  public static final Set<String> SQL_KEYWORDS =
  new HashSet<String>(Arrays.asList("abort", "action", "add", "after", "all", "alter", "analyze", "and", "as", "asc", "attach", "autoincrement", "before", "begin", "between", "by", "cascade", "case", "cast", "check", "collate", "column", "commit", "conflict", "constraint", "create", "cross", "current_date", "current_time", "current_timestamp", "database", "default", "deferrable", "deferred", "delete", "desc", "detach", "distinct", "drop", "each", "else", "end", "escape", "except", "exclusive", "exists", "explain", "fail", "for", "foreign", "from", "full", "glob", "group", "having", "if", "ignore", "immediate", "in", "index", "indexed", "initially", "inner", "insert", "instead", "intersect", "into", "is", "isnull", "join", "key", "left", "like", "limit", "match", "natural", "no", "not", "notnull", "null", "of", "offset", "on", "or", "order", "outer", "plan", "pragma", "primary", "query", "raise", "references", "regexp", "reindex", "release", "rename", "replace", "restrict", "right", "rollback", "row", "savepoint", "select", "set", "table", "temp", "temporary", "then", "to", "transaction", "trigger", "union", "unique", "update", "using", "vacuum", "values", "view", "virtual", "when", "where"));
  
  private final Location l(int yyStart) { return location(yyStart); }
  
  private static final class AnnotationProperty {
    final String _key;
    final String[] _value;
    AnnotationProperty(final String key, final Object value) {
      _key = key;
      _value = (String[])value;
    }
  }
  
  private static final Fragment makeFragment(
  Location startLoc, String language, String phrase,
  List<AnnotationProperty> annotations, FragmentBody body, Location endLoc
  ) {
    CodeType type = new CodeType(language, phrase);
    Map<String, String[]> properties = new TreeMap<String,String[]>();
    for (AnnotationProperty a : annotations)
    properties.put(a._key, a._value);
    FragmentElement[] elements = body.flatten();
    return new Fragment(startLoc, type, elements, properties,
    endLoc.line, endLoc.column);
  }
  
  private static final class FragmentBody extends FragmentElement {
    private List<FragmentElement> _elems;
    FragmentBody(final Location loc, final List<FragmentElement> elems) {
      super(loc);
      _elems = elems;
    }
    FragmentElement[] flatten() {
      final List<FragmentElement> accum = new ArrayList<FragmentElement>();
      flatten(accum);
      return accum.toArray(new FragmentElement[accum.size()]);
    }
    private final void flatten(final List<FragmentElement> accum) {
      for (final FragmentElement elem : _elems) {
        if (elem instanceof FragmentBody) {
          Location loc = new Location(elem.sourceFile,elem._line,elem._column);
          accum.add(new ObjectToken(loc, "[", false, false));
          ((FragmentBody)elem).flatten(accum);
          accum.add(new ObjectToken(loc, "]", false, false));
        } else {
          accum.add(elem);
        }
      }
    }
    public final void accept(final Visitor visitor) {
      assert false : "should be flattened away before traversal";
      System.exit(-1);
    }
  }

}
